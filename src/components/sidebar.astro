---
import type { MarkdownHeading } from "astro";

import { widgetManager } from "@utils/widget";
import Profile from "@components/sidebar/profile.astro";
import Announcement from "@components/sidebar/announcement.astro";
import Categories from "@components/sidebar/categories.astro";
import Tags from "@components/sidebar/tags.astro";
import Statistics from "@components/sidebar/statistics.astro";
import TOC from "@components/sidebar/toc.astro";


interface Props {
    id?: string;
    class?: string;
    headings?: MarkdownHeading[];
    side: "left" | "right" | "middle";
}

const { id, class: className, headings, side } = Astro.props;
const currentPath = Astro.url.pathname;

// 获取所有组件（包括不可见的，用于计算动画状态）
const allTopComponents = widgetManager.getComponentsBySideAndPosition(side, "top");
const allStickyComponents = widgetManager.getComponentsBySideAndPosition(side, "sticky");

// 过滤并添加动画标记
let hasVolatile = false;
const topComponents = allTopComponents.reduce((acc: any[], component) => {
    const isVisible = widgetManager.shouldShowComponent(component, currentPath);
    const isVolatile = !!component.visibility;
    if (isVolatile) hasVolatile = true;

    if (isVisible) {
        acc.push({ ...component, shouldAnimate: hasVolatile, _original: component });
    }
    return acc;
}, []);
const stickyComponents = allStickyComponents.reduce((acc: any[], component) => {
    const isVisible = widgetManager.shouldShowComponent(component, currentPath);
    const isVolatile = !!component.visibility;
    if (isVolatile) hasVolatile = true;

    if (isVisible) {
        acc.push({ ...component, shouldAnimate: hasVolatile, _original: component });
    }
    return acc;
}, []);

// 组件映射表
const componentMap = {
    profile: Profile,
    announcement: Announcement,
    categories: Categories,
    tags: Tags,
    statistics: Statistics,
    toc: TOC,
};

// 渲染组件的辅助函数
function renderComponent(component: any, index: number) {
    const ComponentToRender =
        componentMap[component.type as keyof typeof componentMap];
    if (!ComponentToRender) return null;

    // 使用原始组件引用获取类名（因为 getComponentClass 依赖对象引用判断来源）
    const originalComponent = component._original || component;
    let componentClass = widgetManager.getComponentClass(originalComponent, index, side);
    const componentStyle = widgetManager.getComponentStyle(component, index);

    // 如果组件需要动画，添加 transition-swup-fade 类
    if (component.shouldAnimate) {
        componentClass += " transition-swup-fade";
    }

    return {
        Component: ComponentToRender,
        props: {
            class: componentClass,
            style: componentStyle,
            headings: component.type === "toc" ? headings : undefined,
            depth: component.depth,
        },
    };
}
---

<div id={id || "sidebar"} data-side={side} class:list={[className, "w-full h-full"]}>
    <!-- 顶部固定组件区域 -->
    {topComponents.length > 0 && (
        <div class:list={["flex flex-col w-full gap-4", { "mb-4": stickyComponents.length > 0 }]}>
            {topComponents.map((component, index) => {
                const renderData = renderComponent(component, index);
                if (!renderData) return null;

                const { Component, props } = renderData;
                return <Component {...props} side={side} />;
            })}
        </div>
    )}

    <!-- 粘性组件区域 -->
    {stickyComponents.length > 0 && (
        <div id="sidebar-sticky" class="flex flex-col w-full gap-4 sticky top-4">
            {stickyComponents.map((component, index) => {
                const renderData = renderComponent(component, index);
                if (!renderData) return null;

                const { Component, props } = renderData;
                return <Component {...props} side={side} />;
            })}
        </div>
    )}
</div>